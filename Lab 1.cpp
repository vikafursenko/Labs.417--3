#include <iostream> // - заголовочный файл для cout, << и много чего ещё
#include <locale.h> // - заголовочный файл для функции setlocale()
#include <iomanip> // - заголовочный файл для функций управления печатью bin(), hex() и др.
#include <bitset>

// ТЕМА 1. ОПЕРАТОРЫ C/C++, СТРОЕНИЕ МИНИМАЛЬНОЙ ПРОГРАММЫ C/C++

// main - во-первых - функция, во-вторых - точка входа
// во всей программе должна быть только одна функция main()
int main() 
{ 
	// блоки кода в функциях, операторах, и просто блоки отдельно взятого кода по C/C++ окружаются фигурными скобками

	
	/* Классификация операторов
	* 1. Арифмитические (+, -, *, /, % - остаток от целого деления)
	*    а) Логические или Булевы (|| - оператор "или", && - оператор "и", ! - оператор отрицания)
	                              ++ - увеличить на единицу, или "инкремент"
								  -- - уменьшить на единицу, или "декремент"
	*    б) Побитовые (& - бинарное "и", | - бинарное "или", оператор сдвига влево <<, оператор сдвига вправо >>, 
	                  тильда ~ аналог оператора ! для двоичного представления)
	*    в) Операторы сравнения (> - больше, < - меньше, == - равно)
	                            (>= - больше или равно, <= - меньше или равно)
	* 2. Унарные, бинарные и один тернарный
	     а) Унарные - работающие с единственным операндом (примеры: !, ~, ++, --, и т.д.).
		 б) Бинарные - работающие с двумя операндами (примеры: +, -, /, *, %, <<, >>, &&, ||, &, |, ^, и т.д.)
		 в) Тернарный - работает с тремя операндами (лог_усл?ветка_если_true:ветка_если_false)
		    Операнд - данные, к которым применяется оператор.
	*/

	

	setlocale(LC_ALL, "Russian");
	int a = 10;
	int b = 3;
	int result = 10 % 3;
	std::cout
		<< "Лабораторная работа 1. ОПЕРАТОРЫ C / C++, "
		   "СТРОЕНИЕ МИНИМАЛЬНОЙ ПРОГРАММЫ C / C++"
		<< std::endl;
	std::cout << "a = 10, b = 3" << std::endl; // endl - просто перенос на следующую
	std::cout << "10 % 3 = " << 10 % 3 << "\n"; // \n - то же самое, что и std::endl

	std::cout << "\n" << "Таблица значений операции &&" << std::endl;
	std::cout << "\t\tb = true\tb=false" << std::endl;
	std::cout << "a = true" << "\t" << (true && true) << "\t\t" << (true && false) << std::endl;
	std::cout << "a = false" << "\t" << (false && true) << "\t\t" << (false && false) << "\n" << std::endl;

	std::cout << "Таблица значений операции ||" << std::endl;
	std::cout << "\t\tb = true\tb=false" << std::endl;
	std::cout << "a = true" << "\t" << (true || true) << "\t\t" << (true || false) << std::endl;
	std::cout << "a = false" << "\t" << (false || true) << "\t\t" << (false || false) << "\n" << std::endl;

	bool c = false;
	bool d = true;
	std::cout << "Демонстрация работы оператора отрицания !" << std::endl;
	std::cout << "c = " << c <<  "\t"  << "!c = " << !c << std::endl;
	std::cout << "d = " << d << "\t" << "!d = " << !d << "\n" << std::endl;

	
	// ДЗ

	int binary_int = 0b1010;
	std::cout << "Бинарное число = binary_int " << std::hex << std::bitset<8>(binary_int) << "\n"  << std::endl;

	int binary_int1 = 0b1010;
	int binary_int2 = 0b1100;
	std::cout << "Таблица бинарных значений операции &" << std::endl;
	std::cout << "Бинарное число = " <<std::bitset<4>(binary_int1) << std::endl;
	std::cout << "Бинарное число = " << std::bitset<4>(binary_int2) << std::endl;
	std::cout << "                 ----"<< std::endl;
	std::cout << "Результат        "  << std::bitset<4>( binary_int1 & binary_int2) << "\n" << std::endl;

	std::cout << "Таблица бинарных значений операции |" << std::endl;
	std::cout << "Бинарное число = " << std::bitset<4>(binary_int1) << std::endl;
	std::cout << "Бинарное число = " << std::bitset<4>(binary_int2) << std::endl;
	std::cout << "                 ----" << std::endl;
	std::cout << "Результат        " << std::bitset<4>(binary_int1 | binary_int2) << "\n" << std::endl;

	std::cout << "Таблица бинарных значений операции ^" << std::endl;
	std::cout << "Бинарное число = " << std::bitset<4>(binary_int1) << std::endl;
	std::cout << "Бинарное число = " << std::bitset<4>(binary_int2) << std::endl;
	std::cout << "                 ----" << std::endl;
	std::cout << "Результат        " << std::bitset<4>(binary_int1 ^ binary_int2) << "\n" << std::endl;

	std::cout << std::endl << "Демонстрация работы побитовых операторов" << std::endl;
	std::cout << "a = " << std::bitset<8> (a) << "; b = " << b 
              << "; a >> b = " << std::bitset<8>(a >> b) << std::endl;
	std::cout << "a = " << std::bitset<8> (a) << "; b = " << b 
	          << "; a << b = " << std::bitset<8>(a << b) << std::endl;
	std::cout << "a = " << std::bitset<8>(a) << "; ~a = " << std::bitset<8>(~a) << std::endl;
		      
	// ДЗ

	std::cout << std::endl << "a = " << a << std::endl;
	std::cout << "Оператор ++ после числа: a++ = " << a++ << std::endl;
	std::cout << "После применения инкремента a = " << a << std::endl;
	std::cout << std::endl << "a = " << a << std::endl;
	std::cout << "Оператор ++ перед числом: ++a = " << ++a << std::endl;
	std::cout << "После применения инкремента a = " << a << std::endl;

	

	/* 
	* если оператор ++ стоит после числа, то число сначала выводится на печать, а затем увеличивается
	* если оператор ++ стоит перед числом, то число сначала увеличивается, а затем выводится
	* если в строчке кода применяется только инкремент (перед или после числа), то разницы нет
	*/

	

	/* 
	* \t, \n - т.е. escape - последовательности, управляющие символы
	* они кодируют вывод символов, которые нельзя набрать с клавиатуры (непечатные символы)
    * \t - один символ табуляции (при компиляции компилятор заменяет пару символов /t на один символ табуляции
	* \n - один символ переноса строки (при компиляции компилятор заменяет пару символов \n на один символ переноса строки
	* служебным символом для начала escape - последовательности является
	* если нужно употреблять сам по себе слеш '/' беp escape-последовательности
	* то следует в строке о коде писать '\\'
	* обратный слеш / - это просто символ и особого значения не имеет
	*/

	

	// 2. ТИПЫ ДАННЫХ ЯЗЫКА C/C++
	// 2.1 Целочисленные типы. Используются для хранения целых чисел положительных, отрицательных и беззнаковых.
	char char_var; // char_var - название переменной, может быть любой. Занимает в памяти 8 бит (байт), может хранить числа от -128 до 127
	short short_var; // short_var - название переменной, может быть любой. Занимает в памяти 16 бит (2 байта), может хранить числа от -32768 до 32767
	int int_var; // int_var - название переменной, может быть любой. Занимает в памяти 32 бит (4 байта), может хранить числа от INT32_MIN до INT32_MAX
	long long_var; // long_var - название переменной, может быть любой. Аналогична int
	long int li_var; // li_var - название переменной, может быть любой. Занимает в памяти 64 бит (8 байт), может хранить числа от LLONG_MIN до LLONG_MAX
	long long ll_var; // ll_var - название переменной, может быть любой. Аналогична long int

	// Если приписать к любому целому знаковому типу модификатор unsigned, то
	// 1) положительный диапозон (т.е. максимальное положительное число) увеличивается
    // 2) в число с меткой unsigned уже нельзя будет записать отрицательные числа

	unsigned char uns_char_var; // uns_ll_var - название переменной, может быть любой. Размер тот же, что и у типа char, но диапозон начинается с 0 до 255
	unsigned short uns_short_var; // uns_ll_var - название переменной, может быть любой.
	unsigned int uns_int_var; // uns_ll_var - название переменной, может быть любой.
	unsigned long uns_long_var; // uns_ll_var - название переменной, может быть любой.
	unsigned long int uns_li_var; // uns_ll_var - название переменной, может быть любой.
	unsigned long long uns_ll_var; // uns_ll_var - название переменной, может быть любой.

	// 2.2 Арифмитические типы с плавающей запятой/точкой
	float flt_var; // flt_var - название переменной, может быть любой. Имеет объём 4 байта (32 бита), и может представлять числа от FLT_MIN до FLT_MAX
	double dbl_var; // dbl_var - название переменной, может быть любой. Имеет объём 8 байт (64 бита), и может представлять числа от DBL_MIN до DBL_MAX

    // 2.3 Логические типы данных
	bool bool_var; // bool_var - название переменной, может быть любой. Может представлять всего 2 значения: true и false, но имеет длину
	std::cout << std::endl << "Длина типа bool (в 64-разрядном приложении) sizeof(bool) = " << sizeof(bool) << std::endl;

	// 2.4 Символьные типы данных
	char chr_var; // chr_var - название переменной, может быть любой. Диапазона арифмитического типа char очень кстати хватает на кодирование таблицы символов, поэтому чаще тип char используют именно для хранения символов и строк, чем для арифмитики.
	wchar_t wchr_var; // wchr_var - название переменной, может быть любой. Имеет объём 16 бит (2 байта) и введён для хранения символов юникода или других кодировок

	// 2.5 Универсальный или пустой тип void
    // Компилятор рассматривает void как ячейку с неопределёнными данными
	// Этот служебный тип данных, может использоваться как "заглушка", если функция не возвращает и не принимает значений
	// Либо в сложных конструкциях приведения типов
	



	std::system("pause"); // вызов функции system() из стандартной библиотеки
	return 0;
}  